[
{
	"uri": "http://localhost:1313/fr/overview/goal/",
	"title": "Objectif",
	"tags": [],
	"description": "",
	"content": "Votre objectif sera de TODO\n"
},
{
	"uri": "http://localhost:1313/fr/overview/",
	"title": "Présentation",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Présentation Bienvenue dans cet atelier où TODO.\n"
},
{
	"uri": "http://localhost:1313/fr/overview/architecture/",
	"title": "Architecture",
	"tags": [],
	"description": "",
	"content": "Architecture TODO\n"
},
{
	"uri": "http://localhost:1313/fr/development/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Voici une description de chaque service et de leur interaction :\ntrain-capture-image-app : C\u0026rsquo;est un service Quarkus qui permet de démarrer, tester et d\u0026rsquo;arrêter la capture vidéo. Il expose des points de terminaison RESTful qui peuvent être appelés par d\u0026rsquo;autres services ou clients pour contrôler la capture vidéo.\nintelligent-train : Ce service est responsable de l\u0026rsquo;analyse des données de la vidéo capturée. Il utilise des techniques d\u0026rsquo;apprentissage automatique pour interpréter les données de la vidéo et de fournir des informations basées sur cette analyse.\ntrain-ceq-app : est un service de gestion des événements qui reçoit des informations de l\u0026rsquo;Intelligent Train et d\u0026rsquo;autres services, et déclenche des actions appropriées. Par exemple, si l\u0026rsquo;Intelligent Train détecte un obstacle sur la voie, le service déclenche un événement pour arrêter le train.\ntrain-controller : Comme son nom l\u0026rsquo;indique, ce service est probablement responsable du contrôle du train lui-même. Il recevrait des commandes de services comme le train-ceq et effectuerait des actions sur le train, comme le démarrage, l\u0026rsquo;arrêt, le changement de vitesse, etc.\ntrain-monitoring-app : Ce service est responsable de la surveillance de l\u0026rsquo;ensemble du système. Il recueillerait des données de tous les autres services, comme les événements déclenchés, les actions effectuées, l\u0026rsquo;état du train, etc., et fournirait une vue d\u0026rsquo;ensemble de l\u0026rsquo;état du système. Il pourrait également fournir des alertes ou des notifications en cas de problèmes détectés.\nChaque service est indépendant et communique avec les autres en mode asynchrone (MQTT/Kafka). Cela permet une grande flexibilité et évolutivité, car chaque service peut être développé, déployé et mis à l\u0026rsquo;échelle indépendamment des autres.\n"
},
{
	"uri": "http://localhost:1313/fr/development/",
	"title": "Développement (30min)",
	"tags": [],
	"description": "",
	"content": "Développement L\u0026rsquo;objectif de cette partie est de vous familiariser avec les différents microservices de l\u0026rsquo;application Crazy Train. Vous allez modifier le code de plusieurs projets Quarkus, Python et Nodejs, comprendre comment ils interagissent et tester l\u0026rsquo;application dans son ensemble.\n"
},
{
	"uri": "http://localhost:1313/fr/overview/organization/",
	"title": "Organisation",
	"tags": [],
	"description": "",
	"content": "TODO\n"
},
{
	"uri": "http://localhost:1313/fr/ai/",
	"title": "RHACS (1h)",
	"tags": [],
	"description": "",
	"content": "Partie 2 Intelligence Artificielle "
},
{
	"uri": "http://localhost:1313/fr/development/capture-app/",
	"title": "Service Capture images",
	"tags": [],
	"description": "",
	"content": "capture-app est construite avec Quarkus, un framework Java complet, natif de Kubernetes, conçu pour les machines virtuelles Java (JVM) et la compilation native, optimisant Java spécifiquement pour les conteneurs et lui permettant de devenir une plateforme efficace pour les environnements serverless, cloud et Kubernetes.\nLa fonctionnalité principale du microservice capture-App est de contrôler la capture vidéo. Elle offre la possibilité de démarrer et d\u0026rsquo;arrêter le streaming vidéo, via des points de terminaison RESTful exposés. Ces points de terminaison peuvent être appelés à partir de n\u0026rsquo;importe quel client (comme un navigateur web ou une commande curl dans un terminal) qui supporte HTTP.\nDans le projet capture-app, vous allez ajouter deux nouvelles propriétés dans le fichier application.properties et modifier la classe ScheduledCapture.java pour charger ces propriétés.\nModifier le fichier de configuration : Ouvrez le fichier de configuration de votre application. Il s\u0026rsquo;agit du fichier nommé src/main/application.properties. Ajoutez les propriétés suivantes : Ajoutez les deux nouvelles propriétés à la fin du fichier : %dev.capture.mock=true %dev.capture.videoPath=/projects/rivieradev-app/capture-app/src/main/resources/videos/track-christmas-tree.avi) Enregistrez vos modifications.\nOuvrez le fichier src/main/java/com/train/capture/app/ScheduledCapture.java.\nAjoutez les annotations @ConfigProperty pour charger les nouvelles propriétés. Ajoutez ces lignes en haut de la classe, juste en dessous de la déclaration de la classe :\n@ConfigProperty(name = \u0026#34;capture.mock\u0026#34;) boolean mock; @ConfigProperty(name = \u0026#34;capture.videoPath\u0026#34;) String videoPath; Vérification du code La classe src/main/java/com/train/capture/app/ScheduledCapture.java devrait ressembler à :\npackage org.redhat.demo.crazytrain.captureimage; import jakarta.enterprise.context.ApplicationScoped; import jakarta.enterprise.event.Observes; import jakarta.inject.Inject; import jakarta.ws.rs.GET; import jakarta.ws.rs.POST; import jakarta.ws.rs.Path; import jakarta.ws.rs.core.Response; import jakarta.ws.rs.core.Response.ResponseBuilder; import java.util.ArrayList; import java.util.List; import org.eclipse.microprofile.config.inject.ConfigProperty; import org.eclipse.paho.client.mqttv3.MqttException; import org.jboss.logging.Logger; import org.opencv.core.Mat; import org.opencv.core.Size; import org.opencv.imgproc.Imgproc; import org.opencv.videoio.VideoCapture; import org.opencv.videoio.Videoio; import org.redhat.demo.crazytrain.mqtt.MqttPublisher; import org.redhat.demo.crazytrain.util.Util; import io.quarkus.runtime.StartupEvent; import io.quarkus.scheduler.Scheduled; import io.vertx.mutiny.core.Vertx; /** * ScheduledCapture is a service that captures images from a camera using the OpenCV library */ @ApplicationScoped @Path(\u0026#34;/capture\u0026#34;) public class ScheduledCapture { private VideoCapture camera; @Inject ImageCaptureService imageCaptureService; @Inject ImageService imageService; @Inject Vertx vertx; // interval in milliseconds @ConfigProperty(name = \u0026#34;capture.interval\u0026#34;) int interval; // tmpFolder is the folder where the images are saved @ConfigProperty(name = \u0026#34;capture.tmpFolder\u0026#34;) String tmpFolder; // broker is the MQTT broker @ConfigProperty(name = \u0026#34;capture.brokerMqtt\u0026#34;) String broker; // topic is the MQTT topic @ConfigProperty(name = \u0026#34;capture.topic\u0026#34;) String topic; // nbImgSec is the number of images captured every second @ConfigProperty(name = \u0026#34;capture.periodicCapture\u0026#34;) int periodicCapture; @ConfigProperty(name = \u0026#34;capture.saveImage\u0026#34;) boolean saveImage; @ConfigProperty(name = \u0026#34;capture.videoDeviceIndex\u0026#34;) int videoDeviceIndex; @ConfigProperty(name = \u0026#34;capture.mock\u0026#34;) boolean mock; @ConfigProperty(name = \u0026#34;capture.videoPath\u0026#34;) String videoPath; @ConfigProperty(name = \u0026#34;capture.videoPeriodicCapture\u0026#34;) int videoPeriodicCapture; MqttPublisher mqttPublisher = null; private Long timerId; private volatile boolean stopRequested = false; private Thread testThread; private static final Logger LOGGER = Logger.getLogger(ScheduledCapture.class); Util util = null; // Start the camera when the application starts and set the resolution void onStart(@Observes StartupEvent ev) { Logger.getLogger(ScheduledCapture.class).info(\u0026#34;The application is starting...\u0026#34;); if(!mock){ camera = new VideoCapture(videoDeviceIndex); camera.set(Videoio.CAP_PROP_FRAME_WIDTH, 640); // Max resolution for Logitech C505 camera.set(Videoio.CAP_PROP_FRAME_HEIGHT, 480); // Max resolution for Logitech C505 //camera.set(Videoio.CAP_PROP_AUTOFOCUS, 0); // Try to disable autofocus //camera.set(Videoio.CAP_PROP_FOCUS, 255); // Try to disable autofocus camera.set(Videoio.CAP_PROP_EXPOSURE, 15); // Try to set exposure } util = new Util(); mqttPublisher = new MqttPublisher(broker.trim(), topic.trim()); } void readVideo(String videoPath) { VideoCapture capture = new VideoCapture(videoPath); if (!capture.isOpened()) { throw new IllegalArgumentException(\u0026#34;Video file not found at \u0026#34; + videoPath); } double fps = capture.get(Videoio.CAP_PROP_FPS); int frameSkip = (int) (fps/8); int count = 0; Mat frame = new Mat(); while (!stopRequested) { // Continue reading the video until a stop request is received while (capture.read(frame)) { if (count % frameSkip == 0) { // Publish the image to the MQTT broker long timestamp = System.currentTimeMillis(); if(util != null) { long start2 = System.nanoTime(); String jsonMessage = util.matToJson(frame, timestamp); long end2 = System.nanoTime(); LOGGER.debugf(\u0026#34;Time to convert image to json: %d ms\u0026#34;, (end2 - start2) / 1000000); LOGGER.debugf(\u0026#34;JSON Message with id %s\u0026#34;, jsonMessage); try { long start3 = System.nanoTime(); mqttPublisher.publish(jsonMessage); long end3 = System.nanoTime(); LOGGER.debugf(\u0026#34;Time to publish image: %d ms\u0026#34;, (end3 - start3) / 1000000); LOGGER.debugf(\u0026#34;Message with id %s published to topic: %s\u0026#34;, timestamp, topic); } catch (MqttException e) { e.printStackTrace(); } } if(saveImage){ String filepath = tmpFolder+\u0026#34;/\u0026#34; + timestamp + \u0026#34;.jpg\u0026#34;; imageService.saveImageAsync(frame, filepath).thenAccept(success -\u0026gt; { if (success) { LOGGER.debug(\u0026#34;Frame saved successfully\u0026#34;); } else { LOGGER.error(\u0026#34;Failed to save frame\u0026#34;); } }); } } count++; if (stopRequested) { // Check if stop has been requested inside the inner loop as well break; } } capture.set(Videoio.CAP_PROP_POS_FRAMES, 0); // Reset the video to the first frame } capture.release(); } // Capture and save a defined number of images every second void captureAndSaveImage() { LOGGER.debugf(\u0026#34;The Thread name is %s\u0026#34; + Thread.currentThread().getName()); // Capture the image long start = System.nanoTime(); Mat image = imageCaptureService.captureImage(this.camera); long end = System.nanoTime(); LOGGER.debugf(\u0026#34;Time to capture image: %d ms\u0026#34;, (end - start) / 1000000); // Publish the image to the MQTT broker long timestamp = System.currentTimeMillis(); if(util != null) { long start2 = System.nanoTime(); String jsonMessage = util.matToJson(image, timestamp); long end2 = System.nanoTime(); LOGGER.debugf(\u0026#34;Time to convert image to json: %d ms\u0026#34;, (end2 - start2) / 1000000); LOGGER.debugf(\u0026#34;JSON Message with id %s\u0026#34;, jsonMessage); try { long start3 = System.nanoTime(); mqttPublisher.publish(jsonMessage); // Check if stop has been requested if (stopRequested) { // Stop capture and release camera vertx.cancelTimer(timerId); timerId = null; imageCaptureService.releaseCamera(this.camera); mqttPublisher.disconnect(); LOGGER.info(\u0026#34;Capture stopped\u0026#34;); return; } long end3 = System.nanoTime(); LOGGER.debugf(\u0026#34;Time to publish image: %d ms\u0026#34;, (end3 - start3) / 1000000); LOGGER.debugf(\u0026#34;Message with id %s published to topic: %s\u0026#34;, timestamp, topic); } catch (MqttException e) { e.printStackTrace(); } } // Save the image to the file system (asynchronously) if(saveImage){ String filepath = tmpFolder+\u0026#34;/\u0026#34; + timestamp + \u0026#34;.jpg\u0026#34;; imageService.saveImageAsync(image, filepath).thenAccept(success -\u0026gt; { if (success) { LOGGER.debug(\u0026#34;Image saved successfully\u0026#34;); } else { LOGGER.error(\u0026#34;Failed to save image\u0026#34;); } }); } } @POST @Path(\u0026#34;/start\u0026#34;) public Response start() { LOGGER.info(\u0026#34;Capture started\u0026#34;); stopRequested = false; mqttPublisher.connect(); //captureEnabled = true; if (timerId != null) { return Response.status(Response.Status.BAD_REQUEST).entity(\u0026#34;Capture is already running\u0026#34;).build(); } timerId = vertx.setPeriodic(periodicCapture, id -\u0026gt; captureAndSaveImage()); return Response.ok(\u0026#34;Capture started\u0026#34;).build(); } @POST @Path(\u0026#34;/test\u0026#34;) public Response test() { LOGGER.info(\u0026#34;Test started\u0026#34;); stopRequested = false; mqttPublisher.connect(); if (timerId != null) { return Response.status(Response.Status.BAD_REQUEST).entity(\u0026#34;Capture is already running\u0026#34;).build(); } testThread = new Thread(() -\u0026gt; readVideo(videoPath)); testThread.start(); return Response.ok(\u0026#34;read video from file started\u0026#34;).build(); } @POST @Path(\u0026#34;/stop\u0026#34;) public Response stop() { stopRequested = true; LOGGER.info(\u0026#34;Stop requested\u0026#34;); if (testThread != null) { try { testThread.join(); // Wait for the testThread to finish } catch (InterruptedException e) { Thread.currentThread().interrupt(); // Restore interrupted status } testThread = null; } return Response.ok(\u0026#34;Stop requested\u0026#34;).build(); } } Le fichier application.properties devrait ressembler à :\n%dev.quarkus.http.port=8082 %dev.capture.mock=true %dev.catpure.videoPath=/projects/rivieradev-app/capture-app/src/main/resources/videos/track-christmas-tree.avi %dev.catpure.videoPeriodicCapture=30 quarkus.kafka.devservices.enabled=false quarkus.swagger-ui.always-include=true capture.videoDeviceIndex=${VIDE0_DEVICE_INDEX:0} capture.dropbox.token=${DROPBOX_TOKEN:null} capture.tmpFolder=${TMP_FOLDER:/Users/mouchan/crazy-train-images} capture.interval=${INTERVAL:100} capture.periodicCapture=${PERIODIC_CAPTURE:30} capture.brokerMqtt=${MQTT_BROKER:tcp://localhost:1883} capture.topic=${MQTT_TOPIC:train-image} capture.videoPath=${VIDEO_PATH:/projects/rivieradev-app/capture-app/src/main/resources/videos/track-christmas-tree.avi} capture.videoPeriodicCapture=${VIDEO_PERIODIC_CAPTURE:30} capture.saveImage=${SAVE_IMAGE:false} capture.mock=${MOCK:false} quarkus.log.level=${LOGGER_LEVEL:INFO} Compilation du projet Avant de committer vos modifications, vous devez construire le projet pour vous assurer qu\u0026rsquo;il n\u0026rsquo;y a pas d\u0026rsquo;erreurs de compilation.\n1. Ouverez un nouveau terminal ![terminal](/images/dev-section/new-terminal-bash.png) 2. Lancez la commande ci-dessous ``` ./mvnw clean package ``` "
},
{
	"uri": "http://localhost:1313/fr/overview/openshift/",
	"title": "OpenShift",
	"tags": [],
	"description": "",
	"content": "OpenShift cluster TODO\nDétails du cluster OpenShift URL de la console du cluster OCP : https://console-openshift-console.apps.TODO\nURL de l\u0026rsquo;API du cluster OCP : https://api.TODO:6443\nIl existe un utilisateur OpenShift dédié pour chaque utilisateur. Sur votre table, vous trouverez une affiche avec les informations pertinentes. Pour vous connecter à votre cluster Openshift, cliquez sur URL de la console OCP Cluster ci-dessus et renseignez votre nom d\u0026rsquo;utilisateur et votre mot de passe. Vous aurez accès au Terminal Web en cliquant sur l\u0026rsquo;icône \u0026gt;_ en haut à droite. Le Terminal Web fournit le client oc.\n"
},
{
	"uri": "http://localhost:1313/fr/development/intelligent-train/",
	"title": "Service intelligent-train",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/fr/development/train-ceq-app/",
	"title": "Service train-ceq-app",
	"tags": [],
	"description": "",
	"content": "Le train-ceq-app est une application basée sur Apache Camel, une bibliothèque Java pour la mise en œuvre des intégrations d\u0026rsquo;applications à l\u0026rsquo;aide de l\u0026rsquo;Enterprise Integration Patterns (EIP). Cette application est principalement composée de routes Camel définies dans le fichier PostProcessingRoute.xml. Ces routes définissent comment les messages sont consommés, transformés et transmis à d\u0026rsquo;autres services ou destinations.\nLa route postproscesing-route effectue les opérations suivantes:\nConsommation des messages : La route commence par consommer les messages du broker MQTT à l\u0026rsquo;aide de l\u0026rsquo;URI paho:{{train.mqtt.source.topicName}}?brokerUrl={{train.mqtt.brokerUrl}}. Les messages consommés sont ensuite enregistrés dans le log.\nSauvegarde du message initial : Le message initial est sauvegardé dans l\u0026rsquo;entête du message sous le nom \u0026ldquo;origin\u0026rdquo; pour pouvoir être récupéré plus tard.\nExtraction de l\u0026rsquo;ID du message : L\u0026rsquo;ID du message est extrait à l\u0026rsquo;aide de l\u0026rsquo;expression JSONPath $.id et est enregistré dans l\u0026rsquo;entête du message.\nDésérialisation du message : Le message est désérialisé en un objet Java de type org.redhat.demo.crazytrain.model.Result à l\u0026rsquo;aide de la bibliothèque Jackson.\nTraitement du message : Le message est ensuite traité par le CommandProcessor.\nPublication du message : Le message traité est publié sur un autre topic MQTT à l\u0026rsquo;aide de l\u0026rsquo;URI paho:{{command.mqtt.destination.topicName}}?brokerUrl={{train.mqtt.brokerUrl}}.\nRécupération du message initial : Le message initial sauvegardé dans l\u0026rsquo;entête est récupéré et remis dans le corps du message.\nGénération de l\u0026rsquo;événement cloud : Un événement cloud est généré à partir du message initial et est traité par le CloudEventProcessor.\nPublication de l\u0026rsquo;événement cloud : L\u0026rsquo;événement cloud est publié sur un topic Kafka à l\u0026rsquo;aide de l\u0026rsquo;URI kafka:{{monitoring.kafka.destination.topicName}}?brokers={{train.kafka.brokerUrl}}.\nLa route command-capture-image fonctionne de manière similaire, mais consomme les messages d\u0026rsquo;un topic Kafka, extrait une commande à partir du message, et envoie une requête HTTP POST à une URL spécifiée avec la commande comme paramètre.\nDans une route camel les données sont continuellement transformés par différentes actions. Parfois il est nécessaire d\u0026rsquo;effectuer un contrôle sur le message d\u0026rsquo;origine et non pas sur le message transformé. Il est de bonne pratique de sauvgrader le message initial afin de pouvoir le récupérer plus tard. Avec Camel ceci se fait via les propriétés de l\u0026rsquo;entete du message.\nDans le projet train-ceq-app, vous allez modifier le fichier PostProcessingRoute.xml pour sauvegarder le message initial et pouvoir le récupérer plus tard.\nOuvrez le fichier src/main/resources/PostProcessingRoute.xml. Ajoutez l\u0026rsquo;instruction suivante juste après la ligne \u0026lt;log loggingLevel=\u0026quot;DEBUG\u0026quot; message=\u0026quot;${body}\u0026quot;/\u0026gt; : \u0026lt;setHeader name=\u0026#34;origin\u0026#34;\u0026gt;\u0026lt;simple\u0026gt;${body}\u0026lt;/simple\u0026gt;\u0026lt;/setHeader\u0026gt; Cette instruction sauvegarde le message initial dans l\u0026rsquo;entête du message sous le nom \u0026ldquo;origin\u0026rdquo;.\nEnsuite, ajoutez l\u0026rsquo;instruction suivante juste après la ligne \u0026lt;toD uri=\u0026quot;paho:{{command.mqtt.destination.topicName}}?brokerUrl={{train.mqtt.brokerUrl}}\u0026quot;/\u0026gt; : \u0026lt;setBody\u0026gt;\u0026lt;simple\u0026gt;${header.origin}\u0026lt;/simple\u0026gt;\u0026lt;/setBody\u0026gt; Cette instruction récupère le message initial sauvegardé dans l\u0026rsquo;entête et le remet dans le corps du message.\nEnregistrez vos modifications. Maintenant, la route src/main/resources/PostProcessingRoute.xml sauvegarde le message initial et le récupère plus tard. Cela permet d\u0026rsquo;effectuer un contrôle sur le message d\u0026rsquo;origine et non pas sur le message transformé.\nVoici à quoi devrait ressembler la route après vos modifications :\n\u0026lt;routes xmlns=\u0026#34;http://camel.apache.org/schema/spring\u0026#34;\u0026gt; \u0026lt;route id=\u0026#34;postproscesing-route\u0026#34;\u0026gt; \u0026lt;from uri=\u0026#34;paho:{{train.mqtt.source.topicName}}?brokerUrl={{train.mqtt.brokerUrl}}\u0026#34;/\u0026gt; \u0026lt;log loggingLevel=\u0026#34;DEBUG\u0026#34; message=\u0026#34;MQTT message received:\u0026#34;/\u0026gt; \u0026lt;log loggingLevel=\u0026#34;DEBUG\u0026#34; message=\u0026#34;${body}\u0026#34;/\u0026gt; \u0026lt;setHeader name=\u0026#34;origin\u0026#34;\u0026gt;\u0026lt;simple\u0026gt;${body}\u0026lt;/simple\u0026gt;\u0026lt;/setHeader\u0026gt; \u0026lt;setHeader name=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;jsonpath\u0026gt;$.id\u0026lt;/jsonpath\u0026gt;\u0026lt;/setHeader\u0026gt; \u0026lt;log message=\u0026#34;Id of the message: ${header.id}\u0026#34;/\u0026gt; \u0026lt;unmarshal\u0026gt; \u0026lt;json library=\u0026#34;Jackson\u0026#34; unmarshalType=\u0026#34;org.redhat.demo.crazytrain.model.Result\u0026#34;/\u0026gt;\u0026lt;/unmarshal\u0026gt; \u0026lt;log message=\u0026#34;unmarshalling done\u0026#34;/\u0026gt; \u0026lt;process ref=\u0026#34;CommandProcessor\u0026#34;/\u0026gt; \u0026lt;log message=\u0026#34;Train Command: ${body}\u0026#34;/\u0026gt; \u0026lt;toD uri=\u0026#34;paho:{{command.mqtt.destination.topicName}}?brokerUrl={{train.mqtt.brokerUrl}}\u0026#34;/\u0026gt; \u0026lt;setBody\u0026gt;\u0026lt;simple\u0026gt;${header.origin}\u0026lt;/simple\u0026gt;\u0026lt;/setBody\u0026gt; \u0026lt;convertBodyTo type=\u0026#34;java.lang.String\u0026#34;/\u0026gt; \u0026lt;log loggingLevel=\u0026#34;DEBUG\u0026#34; message=\u0026#34;generating cloud event ${body}\u0026#34;/\u0026gt; \u0026lt;process ref=\u0026#34;CloudEventProcessor\u0026#34;/\u0026gt; \u0026lt;log loggingLevel=\u0026#34;DEBUG\u0026#34; message=\u0026#34;${body}\u0026#34;/\u0026gt; \u0026lt;toD uri=\u0026#34;kafka:{{monitoring.kafka.destination.topicName}}?brokers={{train.kafka.brokerUrl}}\u0026#34;/\u0026gt; \u0026lt;log loggingLevel=\u0026#34;DEBUG\u0026#34; message=\u0026#34;written into kafka\u0026#34;/\u0026gt; \u0026lt;/route\u0026gt; \u0026lt;route id=\u0026#34;command-capture-image\u0026#34;\u0026gt; \u0026lt;from uri=\u0026#34;kafka:{{monitoring.kafka.source.topicName}}?brokers={{train.kafka.brokerUrl}}\u0026#34;/\u0026gt; \u0026lt;setHeader name=\u0026#34;command\u0026#34;\u0026gt;\u0026lt;jsonpath\u0026gt;$.command\u0026lt;/jsonpath\u0026gt;\u0026lt;/setHeader\u0026gt; \u0026lt;toD uri=\u0026#34;{{train.http.url}}/${header.command}?httpMethod=POST\u0026#34; /\u0026gt; \u0026lt;/route\u0026gt; Compilation du projet Avant de committer vos modifications, vous devez construire le projet pour vous assurer qu\u0026rsquo;il n\u0026rsquo;y a pas d\u0026rsquo;erreurs de compilation.\n1. Ouverez un nouveau terminal ![terminal](/images/dev-section/new-terminal-bash.png) 2. Lancez la commande ci-dessous ``` ./mvnw clean package ``` "
},
{
	"uri": "http://localhost:1313/fr/development/train-controller/",
	"title": "Service train-controller",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/fr/development/monitoring-app/",
	"title": "Service monitoring-appp",
	"tags": [],
	"description": "",
	"content": "Le monitoring-appp est une application qui surveille l\u0026rsquo;état et le comportement du train et de ses composants associés. Ce microservice est en charge de la /l\u0026rsquo; :\nCollecte de données : L\u0026rsquo;application monitoring-appp collecte des données à partir d\u0026rsquo;un topic kafka. Cela inclut les événements produit par train-ceq-app.\nAnalyse des données : Une fois les données collectées, l\u0026rsquo;application monitoring-appp ajoute à l\u0026rsquo;image d\u0026rsquo;origine les prédiction calculées précedement.\nVisualisation des données : L\u0026rsquo;application monitoring-appp fournit une interface utilisateur pour visualiser les données du train en temps réel.\nDans le projet monitoring-appp, vous allez modifier certaines propriétés et le code, suivez les instructions ci-dessous : dev\nModifier le fichier de configuration : Ouvrez le fichier de configuration de votre application. Il s\u0026rsquo;agit du fichier nommé src/main/resources/application.properties. Ajoutez les propriétés suivantes : mp.messaging.incoming.train-monitoring.connector=smallrye-kafka mp.messaging.incoming.train-monitoring.topic=${KAFKA_TOPIC_MONITORING_NAME:train-monitoring} mp.messaging.incoming.train-monitoring.cloud-events=false mp.messaging.incoming.train-monitoring.value.deserializer=org.apache.kafka.common.serialization.StringDeserializer Ces propriétés configurent l\u0026rsquo;application pour utiliser le connecteur SmallRye Kafka pour lire les messages du topic Kafka train-monitoring. Le deserialiseur est configuré pour convertir les messages de Kafka, qui sont des bytes, en chaînes de caractères.\nModifier la classe ImageProcessing : Ouvrez le fichier src/main/java/org/redhat/demo/crazytrain/ImageProcessing.java. Ajoutez l\u0026rsquo;annotation @Incoming(\u0026quot;train-monitoring\u0026quot;) à la méthode process. Ci-dessous le résultat :\n@Incoming(\u0026#34;train-monitoring\u0026#34;) public void process(String message) { // code existant } L\u0026rsquo;annotation @Incoming indique que cette méthode doit être appelée chaque fois qu\u0026rsquo;un message est lu du canal train-monitoring. Le message est passé à la méthode en tant que paramètre.\nCes modifications permettent à notre application de consommer des messages du topic Kafka train-monitoring et de les traiter avec la méthode process de la classe ImageProcessing.\nVérification du code La classe src/main/java/org/redhat/demo/crazytrain/ImageProcessing.java devrait ressembler à :\npackage org.redhat.demo.crazytrain.processing; import java.util.Base64; import java.util.concurrent.TimeUnit; import org.eclipse.microprofile.reactive.messaging.Incoming; import jakarta.ws.rs.core.MediaType; import jakarta.ws.rs.GET; import jakarta.ws.rs.Path; import jakarta.ws.rs.Produces; import jakarta.annotation.PostConstruct; import jakarta.inject.Inject; import org.eclipse.microprofile.config.inject.ConfigProperty; import org.jboss.logging.Logger; import org.opencv.core.CvType; import org.opencv.core.Mat; import org.redhat.demo.crazytrain.services.SaveService; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.JsonMappingException; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import io.micrometer.core.instrument.MeterRegistry; import io.micrometer.core.instrument.Timer; import io.smallrye.mutiny.Multi; import io.smallrye.mutiny.operators.multi.processors.BroadcastProcessor; @Path(\u0026#34;/train-monitoring\u0026#34;) public class ImageProcessing { private static final Logger LOGGER = Logger.getLogger(ImageProcessing.class); private final BroadcastProcessor\u0026lt;String\u0026gt; broadcastProcessor = BroadcastProcessor.create(); @Inject SaveService saveService; @ConfigProperty(name = \u0026#34;monitoring.saveImage\u0026#34;) boolean saveImage; @ConfigProperty(name = \u0026#34;monitoring.tmpFolder\u0026#34;) String tmpFolder; @Inject MeterRegistry registry; Timer timer; @PostConstruct void init() { timer = Timer.builder(\u0026#34;image.processing.time\u0026#34;) .description(\u0026#34;Time taken to get a message from Kafka and process it\u0026#34;) .register(registry); } @Incoming(\u0026#34;train-monitoring\u0026#34;) public void process(String result) { LOGGER.debug(\u0026#34;Consumer kafka recived : \u0026#34;+result); long start = System.nanoTime(); ObjectMapper mapper = new ObjectMapper(); JsonNode jsonNode; try { jsonNode = mapper.readTree(result); JsonNode data = jsonNode.get(\u0026#34;data\u0026#34;); String imageBytesBase64 = data.get(\u0026#34;image\u0026#34;).asText(); broadcastProcessor.onNext(imageBytesBase64); long end = System.nanoTime(); timer.record(end - start, TimeUnit.NANOSECONDS); } catch (JsonMappingException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (JsonProcessingException e) { // TODO Auto-generated catch block e.printStackTrace(); } } @GET @Produces(MediaType.SERVER_SENT_EVENTS) public Multi\u0026lt;String\u0026gt; stream() { return broadcastProcessor.toHotStream(); } } Le fichier application.properties doit ressemble à :\n%dev.quarkus.http.port=8086 # Configure the Kafka source kafka.bootstrap.servers=${KAFKA_BOOTSTRAP_SERVERS:localhost:9092} mp.messaging.incoming.train-monitoring.connector=smallrye-kafka mp.messaging.incoming.train-monitoring.topic=${KAFKA_TOPIC_MONITORING_NAME:train-monitoring} mp.messaging.incoming.train-monitoring.cloud-events=false mp.messaging.incoming.train-monitoring.value.deserializer=org.apache.kafka.common.serialization.StringDeserializer mp.messaging.outgoing.commands-out.connector=smallrye-kafka mp.messaging.outgoing.commands-out.topic=${KAFKA_TOPIC_COMMAND_CAPTURE_NAME:train-command-capture} mp.messaging.outgoing.commands-out.value.serializer=org.apache.kafka.common.serialization.StringSerializer monitoring.saveImage=${SAVE_IMAGE:false} monitoring.tmpFolder=${TMP_FOLDER:/tmp/crazy-train-images} quarkus.log.level=${LOGGER_LEVEL:INFO} quarkus.swagger-ui.always-include=true %dev.kafka.topic.train-command-capture.replication.factor=1 %dev.kafka.topic.train-monitoring.replication.factor=1 Compilation du projet Avant de committer vos modifications, vous devez construire le projet pour vous assurer qu\u0026rsquo;il n\u0026rsquo;y a pas d\u0026rsquo;erreurs de compilation.\n1. Ouverez un nouveau terminal ![terminal](/images/dev-section/new-terminal-bash.png) 2. Lancez la commande ci-dessous ``` ./mvnw clean package ``` "
},
{
	"uri": "http://localhost:1313/fr/development/start-services/",
	"title": "Start services",
	"tags": [],
	"description": "",
	"content": " A partir de Devspaces, cliquez sur la barre de recherche en hat et choisir dans la liste déroulante \u0026ldquo;Run Task\u0026rdquo; Sélectionnez la tâche start-all-apps, cette tâches lance en parallèles toutes les applications modifiées précédement.\nCliquez sur Continue without scanning the task outoput Chaque application démarrera dans un terminal. Les terminaux sont accessible en bas à droite, Séléctionnez \u0026rsquo;no\u0026rsquo; sur les pop-up qui indique qu\u0026rsquo;un nouveau processus a démarré et qu\u0026rsquo;il est possible de faire une redirection de port.\nPour vérifier que toutes les application ont bien démarrés, vous devriez avoir les logs suivants : Log capture-app Log intelligent-train Log train-ceq-app Log monitoring-app Log train-controller Maintenant que toutes les applications sont démarrées, nous allons simuler le fonctionnement de notre train intelligent !\n"
},
{
	"uri": "http://localhost:1313/fr/development/test-services/",
	"title": "Test services",
	"tags": [],
	"description": "",
	"content": "Nous allons simuler le fonctionnement du train :\nOuverez un nouveau terminal Executez la commande ci-dessous pour récupérer l\u0026rsquo;URL de la console de monitoring : oc get routes -o jsonpath=\u0026#39;{range .items[*]}{.metadata.annotation s.che\\.routing\\.controller\\.devfile\\.io/endpoint-name}{\u0026#34;\\t\u0026#34;}{.spec.host}{\u0026#34;\\n\u0026#34;}{end}\u0026#39; | gre p monitoring-svc | cut -f 2 Copiez l\u0026rsquo;URL, lancez une nouvelle fênetre de votre navigateur en mode anonyme (afin d\u0026rsquo;avoir un cache vide), insérez l\u0026rsquo;URL. Retournez à votre terminal et exécutez la commande suivante : curl -X \u0026#39;POST\u0026#39; \u0026#39;http://localhost:8082/capture/test\u0026#39; -H \u0026#39;accept: */*\u0026#39; A partir de votre navigateur vous devriez visualiser en temps réel la simulation du train et la détéction des panneaux de signalisation Bravo ! la simulation a bien fonctionné :) maintenant vous pouvez arrêter la simulation en fermant tous les terminaux.\n"
},
{
	"uri": "http://localhost:1313/fr/development/conclusion/",
	"title": "Conclusion",
	"tags": [],
	"description": "",
	"content": "Félicitations, vous avez terminé la section développement ! Vous devriez maintenant avoir une meilleure compréhension de l\u0026rsquo;application Crazy Train et de son architecture basée sur les microservices. Le lab n\u0026rsquo;est pas encore fini ! Dans la section suivante, nous allons découvrir comment déployer nos applications en utilisant les outils gitops\n"
},
{
	"uri": "http://localhost:1313/fr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/fr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/fr/",
	"title": "Welcome",
	"tags": [],
	"description": "",
	"content": "Riviera Dev 2024 - Lab \u0026ldquo;Crazy Train\u0026rdquo; Bienvenue, cher Red Hatter, dans ce Lab où vous découvrirez une partie de l\u0026rsquo;offre Red Hat dans le domaine du Edge Computing et de l\u0026rsquo;IA.\nVous jouerez avec les technologies suivantes :\nTODO Dans cet atelier, vous devrez TODO\nDu plaisir est attendu à venir !\n"
}]